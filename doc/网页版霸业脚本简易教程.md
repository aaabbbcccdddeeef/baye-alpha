# 网页版霸业脚本简易教程
得益于HTML优势，网页版霸业在原版基础上扩展出javascript脚本系统，使得lib制作能高度定制游戏逻辑。


[TOC]


##javascript简要基础
###基本概念
脚本是一种编程语言，不同于普通文档（如XML），脚本主要由一系列的**数据**和对数据的**操作**（语句）构成。

脚本中语句是一条接着一条顺序执行下去的。如：

```javascript
a = 1; //让对象a的值为1 （赋值）
b = a; //让b的值为a的值，此后b的值也为1
a = 2; //让a的值为2，此后a为2，b仍然为1
c = a; //让c的值为a的值，此后a为2，b为1，c为2
```
以上脚本有4条语句，顺序执行。

XML文档描述“**做什么**”，脚本描述“**怎么做**”。

霸业的脚本系统采用javascript语言, 本教程仅讲一些最基本的javascript脚本知识，欲了解更全面，请参考相关资料。
###注释
注释的内容是为了帮助程序员阅读用的，代码执行时注释会被忽略。

`//`标记单行注释开始，每一行的`//`开始到行末的内容为注释。

`/*`和`*/`对，用于标记多行注释，如：

```
/*
这是注释
这也是注释
*/
```
###javascript的数据类型
数字：`123`

字符串: `"赵云"`

对象：`{name: "赵云", age: 20}`

列表: `[1, 2, 3]`

...

###赋值

最基础的动作语句是赋值，赋值就是让一个`名字`关联一个`值`, 其后，我们就可以在需要用到这个`值`的地方使用这个`名字`来代替。

基本语法：

`变量名称=值;`

示例：

```
/*
简单赋值语句
让 a 关联值 1，分号指示语句结束
javascript里面分号是可选的，但为避免歧义，最好每条语句都加上分号
*/

var a = 1;  // var 定义并赋值，首次使用时加上var
a = a + 2;  // 重新赋值, 此后a的值是3
```

没接触过编程语言的朋友一定要注意: **程序里面的`=`符号代表的是一个动作，区别于我们数学里面学的`=`代表一个相等关系**.


###条件判断
有时候程序需要根据不同的条件执行不同的代码，Javasctipt 用`if`来进行条件判断。

示例：

```javascript
var a = 1;
var b = 2;
if (a > b) {
	// 如果 a > b
	console.log("a > b");
}
```
示例2：

```javascript
var a = 1;
if (a > b) {
	// 如果 a > b
	// console.log语句通常用于调试，它将字符串输出到控制台。
	console.log("a > b");
} else if (a == 1) {
	console.log("a = 1");
} else if (a == 0) {
	console.log("a = 2");
} else {
	// 其它情况
	console.log("其它情况");
}
```
###遍历数据
有时候我们需要遍历一个集合里面的每一个元素做操作，比如霸业里面找出符合某种条件的人物。

我们通常使用`for`循环来实现遍历数据，示例：

```javascript
var numbers = [1, 3, 2, 4];
for (var i = 0; i < numbers.length; i++) {
	if (numbers[i] < 3) {
		console.log(numbers[i]);
	}
}
```

`for`循环语法构成如下

```

for (赋值循环初值; 判断条件; 修改循环条件) {
	循环主体语句
}

其它语句

```

**执行流程：**

![for流程图](http://bgwp.oschina.io/baye/doc/flow.jpg)

###函数（function）
如果一段代码是可复用的或是逻辑相对独立，我们可以将其封装称为函数。

基本语法：

```
function 函数名称(参数列表){
	函数体
}

```
函数名称可以忽略，称为匿名函数。

```
// 这种格式是普通的赋值语句， “=”右边的的函数整体是一个值。
变量名称 = function(参数列表) {
	函数体
}
```

示例：

```

function add(x, y) {
	return x + y;
}
var a = add(1, 2); // now, c = 3
var b = add(a, 1);
```
或

```

var add = function(x, y) {
	return x + y;
}
var a = add(1, 2); // now, c = 3
var b = add(a, 1);
```


##霸业脚本系统原理
霸业的脚本系统定义了一个对象`baye.hooks` (旧版引擎为`baye.methods`)，称之为`钩子对象`，此对象作为引擎与脚本衔接的纽带。
引擎在一系列特定的时间点会调用`baye.hooks`里面的`钩子函数`来完成特定任务。

当lib开启了脚本功能后，引擎在启动时会执行`script.js`文件内的代码。因此，`script.js`文件的主要作用就是往`baye.hooks`对象里面填充我们需要关注的`钩子函数`来实现特定功能。

示例：

```javascript
baye.hooks.giveTool = function(context) {
	//简单示例，赏赐成功
	context.result = 1;
}
```
如上，每当引擎执行到赏赐功能的时候会调用`baye.hooks.giveTool`这个钩子函数，达到"*询问*脚本是否要允许赏赐“这个目的。
##霸业脚本编写向导
了解了原理后，我们就可以一步一步来编写霸业脚本了。

假如我们要实现这么一个功能：**每月对AI控制的人物执行升级**

为实现此功能，我们需要在写一些功能代码，并且让引擎在每次策略结束后执行我们的代码。

**Step1: 让引擎每次策略结束后执行我们的代码**

我们设置钩子函数`baye.hooks.tacticStage4`(详细介绍参考[钩子函数手册](#hooks))

```javascript
baye.hooks.tacticStage4 = function() {
	//待续
};
```
**Step2: 遍历所有人物，如果有归属，且归属不是玩家君主, 且等级未满上限，升级之**

```javascript
baye.hooks.tacticStage4 = function() {
	var allPerson = baye.data.g_Persons;
	var playerKingId = baye.data.g_PlayerKing + 1;
	var maxLevel = baye.data.g_engineConfig.maxLevel;
	
	for (var i = 0; i < allPerson.length; i++) {
		var p = allPerson[i];
		if (p.Belong > 0 && p.Belong != playerKingId && p.Level < maxLevel) {
			p.Level = p.Level + 1;
		}
	}
};
```
注：

- 关于`baye.data`内的数据参考后文[数据手册](#datas)
- `allPerson[i]`: 取列表里第`i`个元素（也就是第i个人物的数据）
- `&&`: 并且
- `!=`: 不等于

**Step3: 进一步完善**

当人物处于被俘虏状态时，归属被设置为255，因此进一步排除俘虏被升级

```javascript
baye.hooks.tacticStage4 = function() {
	var allPerson = baye.data.g_Persons;
	var playerKingId = baye.data.g_PlayerKing + 1;
	var maxLevel = baye.data.g_engineConfig.maxLevel;
	
	for (var i = 0; i < allPerson.length; i++) {
		var p = allPerson[i];
		if (
			p.Belong > 0 
			&& p.Belong != playerKingId 
			&& p.Belong != 255 
			&& p.Level < maxLevel
		) {
			p.Level = p.Level + 1;
		}
	}
};
```

**Step4: 加入概率因素**

```javascript
baye.hooks.tacticStage4 = function() {
	var allPerson = baye.data.g_Persons;
	var playerKingId = baye.data.g_PlayerKing + 1;
	var maxLevel = baye.data.g_engineConfig.maxLevel;
	
	for (var i = 0; i < allPerson.length; i++) {
		var p = allPerson[i];
		if (
			p.Belong > 0 
			&& p.Belong != playerKingId 
			&& p.Belong != 255 
			&& p.Level < maxLevel
		) {
			var chance = Math.random(); //产生一个0~1之间的随机数
			if (chance < 0.7) {// 随机数小于0.7升级，也就是70%的概率升级
				p.Level = p.Level + 1;
			}
		}
	}
};
```

##调试
我们使用PC浏览器的**"开发者工具"**来调试脚本。以Chrome浏览器为例，打开baye页面后按`F12`打开“开发者工具”。
如下图：

![打开开发者工具](#)

###实时查看和修改引擎数据
霸业的引擎数据存放在`baye.data`对象中，浏览器控制台中输入`baye.data.`浏览器会弹出自动补全菜单，对象中有哪些属性一览无余。如图：

![自动补全](#)

查看第一个城池的归属：

![查看城池归属](#)

修改第一个城池的归属：

![修改城池归属](#)

修改后移动一下城池光标，可以看到已经实时生效。


###实时替换钩子函数
调试钩子函数时，如果每次修改一点脚本，又重新打包lib->重新加载运行，会非常麻烦。
当我们修改了钩子函数后，只需在浏览器控制台对该钩子重新赋值，该钩子就即时生效。如图：

![修改钩子函数](#)


###添加调试日志
有时候为调试代码中的逻辑是否按预想的逻辑正常执行，我们需要得到一些实时输出信息。
我们用`console.log`来实现日志功能。

例如，前面的升级功能，我们要先看升级功能有没有正常执行，可以添加一些日志：


```javascript
baye.hooks.tacticStage4 = function() {
	var allPerson = baye.data.g_Persons;
	var playerKingId = baye.data.g_PlayerKing + 1;
	var maxLevel = baye.data.g_engineConfig.maxLevel;
	
	for (var i = 0; i < allPerson.length; i++) {
		var p = allPerson[i];
		if (p.Belong > 0 && p.Belong != playerKingId && p.Level < maxLevel) {
			p.Level = p.Level + 1;
			var name = baye.getPersonName(i);
			console.log(name + " 升级为: " + p.Level);
		}
	}
};
```
策略结束后，可见到控制台打印如下：

![打印日志](#)


##霸业API手册
###数据手册
<p id="datas">
霸业引擎数据都导出到了`baye.data`对象里。

以下摘自霸业引擎源码，后续有时间更新更详细说明。

####`baye.data`属性
```c
/*变量定义*/
/*------------------------------------------*/
U8	*g_FightMap;		/* 战斗地图缓存 */
U8	*g_FightPath;		/* 战斗行军计算 */
U8	*g_FgtAtkRng;		/* 攻击范围 */
U16	g_TileId;		/* 当前地图所用tile的ID */
U16	g_EneTmpProv;		/* 战斗模块，敌人粮草临时变量 */
U8	g_MapWid;		/* 战斗地图宽度 */
U8	g_MapHgt;		/* 战斗地图高度 */
U8	g_FoucsX,g_FoucsY;	/* 光标的地图坐标 */
U8	g_MapSX,g_MapSY;	/* 当前地图显示的起始坐标 */
U8	g_PathSX,g_PathSY;	/* 行军范围地图起始坐标 */
U8	g_PUseSX,g_PUseSY;	/* 行军范围使用起始坐标 */
U8	g_BakUpX,g_BakUpY;	/* 将领坐标备份 */
U8	g_CityX,g_CityY;	/* 城市坐标 */
U8	g_FgtOver;		/* 战斗是否结束 */
U8	g_FgtWeather;		/* 战场天气情况 */
U8	g_FgtBoutCnt;		/* 战斗回合计数 */
U8	g_MainGenIdx;		/* 主将序号 */
U8	g_LookEnemy;		/* 是否观看敌人移动 */
U8	g_LookMovie;		/* 是否观看战斗动画 */
U8	g_MoveSpeed;		/* 战斗中移动速度 */
FGTJK	g_FgtParam;		/* 战斗模块接口参数 */
JLPOS	g_GenPos[FGTA_MAX];	/* 将领地图位置及基本属性 */
JLATT	g_GenAtt[2];		/* 攻击状态下的两个将领属性 */

U8  g_AutoUpdateMapXY;

/*变量定义*/
/*------------------------------------------*/
U8 g_PlayerKing;		/*玩家君主*/
U16 g_YearDate;			/*当前日期*/
U8 g_MonthDate;			/*当前日期*/
U8 g_PIdx;			/*历史时期*/
PersonType *g_Persons;		/*存放人才属性指针*/
CityType g_Cities[CITY_MAX];	/*存放城市属性指针*/
U8 g_PersonsQueue[PERSON_MAX];	/*人才队列*/
U8 g_GoodsQueue[GOODS_MAX];	/*道具队列*/
OrderQueueType *g_OrderHead;	/*命令队列头指针*/
OrderQueueType *g_OrderEnd;	/*命令队列末指针*/
CitySetType g_CityPos;		/*当前城市地图显示位置结构*/
U8 g_FromSave = 0;

/*变量定义*/
/*------------------------------------------*/
U8 citymap[SHOWMAP_HS_MAX][SHOWMAP_WS_MAX];	/*当前显示城市地图*/
U8 cavpdb,cavps;			/*战争俘虏临时变量*/
```

####`PersonType`人物数据定义

```
typedef struct Person				/*人才属性 (12 Bytes) */
{
	U8 OldBelong;		/*俘虏的旧归属*/
	U8 Belong;			/*归属*/
	U8 Level;			/*等级*/
	U8 Force;			/*武力*/
	U8 IQ;				/*智力*/
	U8 Devotion;			/*忠诚*/
	U8 Character;			/*性格*/
	U8 Experience;			/*经验*/
	U8 Thew;			/*体力*/
	U8 ArmsType;			/*兵种*/
	U16 Arms;			/*兵力*/
	U8 Equip[2];			/*装备*/
	U8 Age;				/*年龄*/
}PersonType;
```

####`CityType`城池数据定义

```
typedef struct City				/*城市属性(30 Bytes)*/
{
	U8 State;
	U8 Belong;			/*归属*/
	U8 SatrapId;			/*太守编号*/
	U16 FarmingLimit;		/*农业上限*/
	U16 Farming;			/*农业开发度*/
	U16 CommerceLimit;		/*商业上限*/
	U16 Commerce;			/*商业开发度*/
	U8 PeopleDevotion;		/*民忠*/
	U8 AvoidCalamity;		/*防灾*/
	U32 PopulationLimit;		/*人口上限*/
	U32 Population;			/*人口*/
	U16 Money;			/*金钱*/
	U16 Food;			/*粮食*/
	U16 MothballArms;		/*后备兵力*/
	U8 PersonQueue;			/*人才队列*/
	U8 Persons;			/*人才数*/
	U8 ToolQueue;			/*道具队列*/
	U8 Tools;			/*道具数*/
}CityType;
```

####`GOODS`道具数据定义

```
typedef struct {
	U8	idx;			/* 道具序号 */
	U8	useflag;		/* 使用标志：是被使用还是被装备*/
	U8	atRange[30];		/* 攻击范围数据 */
    U8  changeAttackRange; 	/* 是否改变攻击范围 */
	U8	reserved[60-31];
	U8	at;			/* 对武力的加层 */
	U8	iq;			/* 对智力的加层 */
	U8	move;			/* 对移动力的加层 */
	U8	arm;			/* 对兵种的改变 */
}GOODS;
```

####`SKILLEF `技能数据定义

```
typedef	struct {
	U8	aim;				/* 施展目标 */
	U8	state;				/* 技能对目标状态的影响 */
	U16	power;				/* 对兵力的基本伤害 */
	U16	destroy;			/* 对粮草的基本伤害 */
	U8	useMp;				/* 消耗技能点 */
	U8	weather[5];			/* 天气效果（0为不可施展 1-100%效果）*/
	U8	eland[8];			/* 敌人所在地形效果（0为不可施展 1-100%效果）*/
	U8	oland[8];			/* 我方所在地形效果（0为不可施展 1-100%效果）*/
	U8	earm[6];			/* 敌人兵种加层（0为不可施展 1-100%效果）*/
}SKILLEF;
```

####`FGTJK`战场数据定义

```
typedef struct {
	U8	Mode;				/* 玩家的战斗模式FGT_DF|FGT_AT */
	U8	Way;				/* 战斗进攻方向 */
	U16	MapId;				/* 城市战斗地图 */
	U16	MProvender;			/* 玩家粮草 */
	U16	EProvender;			/* 敌人粮草 */
	U8	GenArray[FGTA_MAX];		/* 将领队列 */
}FGTJK;						/* 战斗接口 */
```

####`JLPOS`战场将领数据定义

```
typedef	struct {
	U8	x;				/* 地图坐标x */
	U8	y;				/* 地图坐标y */
	U8	hp;				/* 生命 */
	U8	mp;				/* 技能点 */
	U8	move;				/* 移动力 */
	U8	active;				/* 将领执行命令能力 */
	U8	state;				/* 状态 */
}JLPOS;						/* 将领在地图上的位置 */
```

####`JLATT`战斗双方将领数据定义

```
typedef	struct {
	U8	*level;				/* 将领等级 */
	U8	canny;				/* 中计谋的可能性 */
	U8	ter;				/* 将领所在地形 */
	U8	bile;				/* 愤怒值 */
	U8	armsType;			/* 兵种 */
	U8	*exp;				/* 将领的经验值 */
	U16	*arms;				/* 兵力 */
	U16	at;				/* 攻击力 */
	U16	df;				/* 防御力 */
}JLATT;						/* 执行攻击或被攻击的将领属性 */
```

####`baye.data.g_engineConfig`数据定义

```
typedef struct {
    U8 enableToolAttackRange; //启用"道具改变攻击范围"
    U8 fixCityOffset;    //纠正城市偏移
    U8 fixThewOverFlow;  //修复体力溢出bug
    U8 fixFoodOverFlow;  //修复出征刷粮草
    U8 fixOverFlow16;    //修复多处16位溢出
    U8 fixConsumeMoney;  //启用招降收费
    U8 fixFightMoveOutRange; //修复战场瞬移
    U8 enable16bitConsumeMoney;   //启用扩展金钱消耗(16位)
    U8 enableScript;              //启用脚本
    U8 fixAlienateComsumeThew; //修复离间减小敌将体力问题
    U8 disableSL;              //禁SL
    U8 aiLevelUpSpeed;            //AI升级速度 (0~100, 0使用原版默认策略)

    U8 disableAgeGrow;         //禁用年龄增长
    U8 enableCustomRatio;      //启用自定义参数计算, 下面两线之间的参数总开关
    // ---------------------------
    U16 ratioOfArmsToLevel;    //带兵量和等级的关系, 默认100  (X*R)
    U8 ratioOfArmsToAge;      //带兵量和年龄的关系, 默认0  (X*R)
    U8 ratioOfArmsToIQ;        //带兵量和智力的关系, 默认10  (X*R)
    U8 ratioOfArmsToForce;     //带兵量和武力的关系, 默认10  (X*R)

    U8 ratioOfAttToForce;      //武力对攻击的影响, 默认10  (X*R/10)
    U8 ratioOfAttToIQ;          //智力对攻击的影响, 默认0  (X*R/10)
    U8 ratioOfAttToAge;         //年龄对攻击的影响, 默认0  (X*R/10)

    U8 ratioOfDefenceToForce; //武力对防御的影响, 默认0  (X*R/10)
    U8 ratioOfDefenceToIQ;    //智力对防御的影响, 默认10  (X*R/10)
    U8 ratioOfDefenceToAge;   //年龄对防御的影响, 默认0  (X*R/10)
    // ---------------------------
    U16 ratioOfFoodToArmsPerMouth; // 市政兵力和粮耗(默认50，越大粮耗越少)
    U16 ratioOfFoodToArmsPerDay; //战场兵力和粮耗参数(默认3，越大粮耗越少)
    U8 armsPerDevotion;        //征兵量和民忠的关系(默认20)
    U8 armsPerMoney;           //每个金钱能购买的士兵数(默认10)
    U8 maxLevel;                //最大等级
    U8 responseNoteOfBettle;   //"战斗提示"允许按键跳过(默认0，填2允许)
    U8 aiDefenceMode;          // AI行军策略，默认0追主将，1守城
    U8 aiAttackMethod;          // AI攻击时选择技能/普攻的算法(0原版，1优化版)
} EngineConfig;

```

###钩子函数手册
<p id="hooks">
####`baye.hooks.aiFightCommand`

**功能**：战场调用脚本进行行军计算及战斗命令选择，可利用此钩子实现自定义AI行军算法。

**调用时机**：AI每次计算将领行军策略前

**输入参数**

| 参数          | 类型 | 说明        |
| --------     | ---  | ---------- |
| context.sIdx | U8   | 需要计算的行军将领的`战场序号`           |

**输出参数**

| 参数        | 类型 | 说明        |
| --------   | --- | ---------- |
| context.type   | U8     | 命令类型，0 普攻， 1 技能， 3 休息  |
| context.param  | U8     | 技能序号（如果选择技能）  |
| context.aIdx   | U8     | 攻击或技能目标将领的`战场序号`  |

####`baye.hooks.getSkillIds`

**功能**：获取将领当前能使用的技能

**调用时机**：战场每当AI或玩家使用技能前

**输入参数**

| 参数          | 类型 | 说明        |
| --------     | ---  | ---------- |
| context.sIdx | U8   | 需要计算的行军将领的`战场序号`           |

**输出参数**

| 参数        | 类型 | 说明        |
| --------   | --- | ---------- |
| context.type   | U8     | 命令类型，0 普攻， 1 技能， 3 休息  |
| context.param  | U8     | 技能序号（如果选择技能）  |
| context.aIdx   | U8     | 攻击或技能目标将领的`战场序号`  |


####`baye.hooks.calcAttackRange`
**功能**：计算攻击范围

**调用时机**：战场每次下攻击命令

**输入参数**：

| 参数          | 类型 | 说明        |
| --------     | ---  | ---------- |
| context.personIndex | U8   | 将领`序号`           |
| context.ter | U8   | 将领所处地形           |
| context.type | U8   | 攻击类型，0 普攻，1 技能      |
| context.skillId | U8   | 技能`ID`           |

**输出参数**：

| 参数        | 类型 | 说明        |
| --------   | --- | ---------- |
| context.range   | [U8]     | 攻击范围矩阵  |
| context.rangeSize | U8     | 攻击范围矩阵的边长，如5x5矩阵填写5  |

####`baye.hooks.showSkill`
**功能**：施展技能是否成功

可用于调整技能成功率。

**调用时机**：施展技能时


**输入参数**：

| 参数          | 类型 | 说明        |
| --------     | ---  | ---------- |
| context.ter | U8   | 将领所处地形           |
| context.skillId | U8   | 技能`ID`           |

**输出参数**：

| 参数        | 类型 | 说明        |
| --------   | --- | ---------- |
| context.result   | U8     | 是否成功，0 失败， 1 成功  (原context.success)|

####`baye.hooks.giveTool`
**功能**：用于控制赏赐命令是否成功

**调用时机**：执行赏赐命令，道具即将被装到人物时

**输入参数**：

| 参数          | 类型 | 说明        |
| --------     | ---  | ---------- |
| context.personIndex | U8   | 将领所处地形           |
| context.toolIndex | U8   | 技能`ID`           |

**输出参数**：

| 参数        | 类型 | 说明        |
| --------   | --- | ---------- |
| context.result   | U8     | 是否成功，0 失败， 1 成功  |

####`baye.hooks.takeOffTool`
**功能**：用于控制没收命令是否成功

**调用时机**：执行赏赐命令，道具即将被装到人物时

**输入参数**：

| 参数          | 类型 | 说明        |
| --------     | ---  | ---------- |
| context.personIndex | U8   | 将领所处地形           |
| context.toolIndex | U8   | 技能`ID`           |

**输出参数**：

| 参数        | 类型 | 说明        |
| --------   | --- | ---------- |
| context.result   | U8     | 是否成功，0 失败， 1 成功  |

####`baye.hooks.didOpenNewGame`
**功能**: 自由

**调用时机**: 新开局时

**输入参数**：无

**输出参数**：无

####`baye.hooks.didLoadGame`
**功能**: 自由

**调用时机**: 成功读档后

**输入参数**：无

**输出参数**：无

####`baye.hooks.willSaveGame`
**功能**: 自由

**调用时机**: 执行存档前

**输入参数**：无

**输出参数**：无

####`baye.hooks.tacticStage1`
**功能**: 自由

**调用时机**: 策略阶段1

**输入参数**：无

**输出参数**：无

引擎的运行，最顶层分为如下几个阶段循环运行：

- 判断统一或全军覆灭
- 太守更新
- 玩家策略中 (玩家操作下各种命令，策略结束后继续后续步骤)
- 电脑策略中
- 执行命令（包括市政和军备等命令）
- 执行数据更新策略（如粮草收获等）

现脚本系统在此间插入了5个钩子点：


- 判断统一或全军覆灭
- 太守更新
- 调用tacticStage1
- 玩家策略中 (玩家操作下各种命令，策略结束后继续后续步骤)
- 调用tacticStage2
- 电脑策略中
- 调用tacticStage3
- 执行命令（包括市政和军备等命令）
- 调用tacticStage4
- 执行数据更新策略（如粮草收获等）
- 调用tacticStage5



####`baye.hooks.tacticStage2`
**功能**: 自由

**调用时机**: 策略阶段2

**输入参数**：无

**输出参数**：无

####`baye.hooks.tacticStage3`
**功能**: 自由

**调用时机**: 策略阶段3

**输入参数**：无

**输出参数**：无

####`baye.hooks.tacticStage4`
**功能**: 自由

**调用时机**: 策略阶段5

**输入参数**：无

**输出参数**：无

####`baye.hooks.tacticStage5`
**功能**: 自由

**调用时机**: 策略阶段5

**输入参数**：无

**输出参数**：无

###功能函数
#### `baye.getPersonName(index)`

**功能**：获取人物名称

**参数**：

| 参数          | 类型 | 说明        |
| --------     | ---  | ---------- |
| index | U8   | 将领序号           |

**返回值**：

| 类型       | 说明        |
| --------  | ---------- |
| string    | 人物名称    |

#### `baye.getToolName(index)`

**功能**：获取道具名称

**参数**：

| 参数          | 类型 | 说明        |
| --------     | ---  | ---------- |
| index | U8   | 道具序号           |

**返回值**：

| 类型       | 说明        |
| --------  | ---------- |
| string    | 道具名称    |


#### `baye.getSkillName(index)`

**功能**：获取技能名称

**参数**：

| 参数          | 类型 | 说明        |
| --------     | ---  | ---------- |
| index | U8   | 技能序号           |

**返回值**：

| 类型       | 说明        |
| --------  | ---------- |
| string    | 技能名称    |

#### `baye.getCityName(index)`

**功能**：获取城池名称

**参数**：

| 参数          | 类型 | 说明        |
| --------     | ---  | ---------- |
| index | U8   | 城池序号           |

**返回值**：

| 类型       | 说明        |
| --------  | ---------- |
| string    | 城池名称    |


#### `baye.setCustomData(data)`

**功能**：存入自定义数据，自定义数据会存储进存档当中

**参数**：

| 参数          | 类型 | 说明        |
| --------     | ---  | ---------- |
| data | string   | 自定义数据          |

**返回值**：无

#### `baye.getCustomData()`

**功能**：取出之前存储的自定义数据

**参数**：无

**返回值**：

| 类型       | 说明        |
| --------  | ---------- |
| string    |  之前存储的数据，若没存过，返回null   |
